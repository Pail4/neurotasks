import random

# Инициализируем любым числом крутизны наклона прямой w1 = A
w1 = 0.4
w1_vis = w1 # Запоминаем начальное значение крутизны наклона
# Инициализируем параметр w2 = b - отвечающий за точку прохождения прямой через ос Y
w2 = random.uniform(-4, 4) 
w2_vis = w2 # Запоминаем начальное значение параметра
# Вывод данных начальной прямой
print('Начальная прямая: ', w1, '* X + ', w2)

# Скорость обучения
lr = 0.001
# Зададим количество эпох
epochs = 3000

# Создадим массив (выборку входных данных) входных данных x1
arr_x1 = [1, 2, 3, 3.5, 4, 6, 7.5, 8.5, 9]

# Значение входных данных второго входа всегда равно 1
x2 = 1

# Создадим массив значений (целевых значений)
arr_y = [3, 5.2, 7, 8.3, 9.2, 12.7, 16.1, 17.8, 19.5]

# Прогон по выборке
for e in range(epochs):
    for i in range(len(arr_x1)): # len(arr) - функция возвращает длину массива
        # Получить x координату точки
        x1 = arr_x1[i]
        
        # Получить расчетную y, координату точки
        y = w1 * x1 + w2 
        
        # Получить целевую Y, координату точки
        target_Y = arr_y[i]

        # Ошибка E = -(целевое значение - выход нейрона)
        E = - (target_Y - y)
 
        # Меняем вес при x, в соответствии с правилом обновления веса
        w1 -= lr * E * x1
        
        # Меняем вес при x2 = 1 
        #w2 -= rate * E * x2 # Т.к. x2 = 1, то этот множитель можно не писать
        w2 -= lr * E 

# Вывод данных готовой прямой
print('Готовая прямая: ', w1, '* X + ', w2)

import matplotlib.pyplot as plt

# Функция для отображения входных данных
def func_data(x_data):
    return [arr_y[i] for i in range(len(arr_y))]

# Функция для отображения начальной прямой
def func_begin(x_begin):
    return [w1_vis*i + w2_vis  for i in x_begin]

# Функция для отображения готовой прямой
def func(x):
    return [w1*i + w2 for i in x]

# Значения по X входных данных 
x_data = arr_x1

# Значения по X начальной прямой (диапазон значений) 
x_begin = [i for i in range(0, 11)]

# Значения по X готовой прямой (диапазон значений) 
x = [i for i in range(0, 11)]
#x = np.arange(0,11,1)

# Значения по Y входных данных
y_data = func_data(x_data)

# Значения по Y начальной прямой
y_begin = func_begin(x_begin)

# Значения по Y готовой прямой
y = func(x)

# Зададим имена графику и числовым координатам
plt.title("Neuron_evolution_№1")
plt.xlabel("X")
plt.ylabel("Y")

# Зададим имена входным данным и прямым 
plt.plot(x,y, label='Входные данные', color = 'g') 
plt.plot(x,y, label='Готовая прямая', color = 'r')
plt.plot(x,y, label='Начальная прямая', color = 'b') 
plt.legend(loc=2) #loc - локация имени, 2 - справа в углу

# представляем точки данных (х,у) кружочками диаметра 10
plt.scatter(x_data, y_data, color ='g', s=10) 
# Начальная прямая
plt.plot(x_begin, y_begin, 'b')
# Готовая прямая
plt.plot(x, y, 'r') 
# Сетка на фоне для улучшения восприятия
plt.grid(True, linestyle='-', color='0.75')

x1 = input("Введите значение ширины Х: ")
x1 = int(x1)
T = input("Введите значение высоты Y: ")
T = int(T)
y = w1 * x1 + w2

# Условие
if T > y:
    print('Это жираф!')
else:
    print('Это крокодил!')

# Показать график 
plt.show()